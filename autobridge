#!/usr/bin/python3 -u
# Note unbuffered output

import os, sys
from fnmatch import fnmatch
from time import sleep
from getopt import getopt
import subprocess

usage="""
Usage:

    autobridge [options] pattern [... pattern] bridge

Given one or more glob-style network interface name patterns and a bridge name,
create the bridge if necessary and add matching interfaces to it as they
appear.

Options are:

    -i ip.ad.re.ss/nm - specify static IP for the bridge.

    -x pattern - interfaces that match this patterm will always be ignored. Can
    be used multiple times.

    -u inteface - define the upstream interface, the bridge will cycle down
    and up whenever this interface has a carrier up event.

"""

# return list of network interfaces
def interfaces(): return os.listdir('/sys/class/net')

# execute the 'ip' command with given command line
def ip(cmd): return subprocess.call(["ip"] + cmd.split())

# return true if string s matches any listed glob
def matches(s, globs):
    for g in globs:
        if fnmatch(s, g):
            return True
    return False

# parse command line param
bridge = sys.argv[-1]
exclude={'lo', bridge}
include=set()
upstream=None
staticip=None

try:
    opts, args = getopt(sys.argv[1:],"u:x:i:")
    if len(args) < 2: raise Exception("Must specify at least one pattern and a bridge name.")
    include.update(args[:-1])
    bridge=args[-1]
    for opt, arg in opts:
        if opt == "-i":
            if staticip: raise Exception("Can't specify -i more than once.")
            staticip = arg
        elif opt == "-x":
            exclude.add(arg)
        elif opt == "-u":
            if upstream: raise Exception("Can't specify -u more than once.")
            upstream = arg      # remember it
            include.add(arg)    # also autobridge it

except Exception as e:
    print (str(e), usage, file=sys.stderr)
    quit(1)

print("Using bridge %s" % bridge)

if bridge not in interfaces():
    if ip("link add name %s type bridge" % bridge):
        raise Exception("Could not create bridge")

if staticip:
    print("Setting static IP %s" % staticip)
    ip("address flush dev %s" % bridge)
    if ip("address add %s dev %s" % (staticip, bridge)):
        raise Exception("Could not set bridge IP")

if ip("link set dev %s up" % bridge): raise Exception("Could not up bridge")

print("Auto-bridging interfaces that match %s but not %s" % (str(include)[1:-1], str(exclude)[1:-1]))
if upstream: print("Upstream interface is %s" % upstream)

ignore = [] # Interfaces that failed to add properly

upcount = None  # Upstream interface up count

while True:
    current=interfaces()

    # unignore interfaces that no longer exist (e.g. unplugged usb)
    for i in set(ignore) - set(current): ignore.remove(i)

    # add new interfaces to bridge
    for i in set(current) - set(os.listdir('/sys/class/net/%s/brif' % bridge)):
        if matches(i, include) and not matches(i, exclude) and not matches(i, ignore):
            print("Adding %s to bridge" % i)
            if ip("link set dev %s master %s up" % (i, bridge)):
                print("Could not add %s, ignoring it" % i)
                ignore.append(i)

    # Cycle the bridge state whenever upstream interface changes(intended to trigger dhcpcd).
    if upstream:
        if upstream in current:
            with open("/sys/class/net/%s/carrier_up_count" % upstream) as f: u=f.read().strip()
            if u != upcount:
                upcount = u
                print("%s upcount is %s, cycling the bridge" % (upstream, upcount))
                if ip("link set dev %s down" % bridge): raise Exception("Could not down bridge")
                if ip("link set dev %s up" % bridge): raise Exception("Could not up bridge")
        else:
            upcount = None

    # Repeat every second
    sleep(1)
