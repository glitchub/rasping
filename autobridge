#!/usr/bin/python3 -u
# Note unbuffered output

import os, sys
from getopt import getopt
import subprocess
import rtnl

usage="""
Usage:

    autobridge [options] pattern [... pattern] bridge

Given one or more glob-style network interface name patterns and a bridge name,
create the bridge if necessary and add matching interfaces to it as they
appear.

Options are:

    -i ip.ad.re.ss/nm - specify static IP for the bridge.

    -x pattern - interfaces that match this patterm will always be ignored. Can
    be used multiple times.

    -u inteface - bridge will be down when the upstream interface is missing or
    doesn't have carrier.

"""

# return list of network interfaces, scraped from sysfs
def interfaces(): return os.listdir('/sys/class/net')

# execute the 'ip' command with given command line
def ip(cmd): return subprocess.call(["ip"] + cmd.split())

# parse command line param
bridge = sys.argv[-1]   # bridge name
reject={'lo', bridge}   # list of interfaces to ignore
accept=set()            # list of interfaces to be bridged
upstream=None           # upstream interface, if any
staticip=None           # static IP to apply to bridge, if any

try:
    opts, args = getopt(sys.argv[1:],"u:x:i:")
    if len(args) < 2: raise Exception("Must specify at least one pattern and a bridge name.")
    accept.update(args[:-1])
    bridge=args[-1]
    for opt, arg in opts:
        if opt == "-i":
            if staticip: raise Exception("Can't specify -i more than once.")
            staticip = arg
        elif opt == "-x":
            reject.add(arg)
        elif opt == "-u":
            if upstream: raise Exception("Can't specify -u more than once.")
            upstream = arg     # remember it
            accept.add(arg)    # also autobridge it

except Exception as e:
    print(str(e), usage, file=sys.stderr)
    quit(1)

print("Using bridge %s" % bridge)

# create bridge if necessary
if bridge not in interfaces():
    if ip("link add name %s type bridge" % bridge):
        raise Exception("Could not create bridge")

if staticip:
    print("Setting static IP %s" % staticip)
    ip("address flush dev %s" % bridge)
    if ip("address add %s dev %s" % (staticip, bridge)):
        raise Exception("Could not set bridge IP")

# initially force bridge up
if ip("link set dev %s up" % bridge): raise Exception("Could not up bridge")
upbridge=True

print("Auto-bridging interfaces that match %s but not %s" % (str(accept)[1:-1], str(reject)[1:-1]))
if upstream: print("Upstream interface is %s" % upstream)

bridged = set() # interfaces that we have added to the bridge (or attempted to add but failed)

# configure netlink
nl=rtnl.rtnl(reject=reject, accept=accept)
nl.dump()   # request initial interface dump
for event in nl.read():
    if not event: continue  # end of dump

    print("%s: attached=%s up=%s carrier=%s" % (event.ifname, event.attached, event.up, event.carrier))

    if not event.attached:
        bridged.discard(event.ifname)
    elif event.ifname not in bridged:
        print("Adding %s to bridge" % event.ifname)
        # this also forces the interface up
        if ip("link set dev %s master %s up" % (event.ifname, bridge)):
            print("Could not add %s, ignoring it" % event.ifname)
        bridged.add(event.ifname)

    # Bridge goes up or down when upstream interface does. This is enabled when
    # dhcpcd is listening on the bridge interface.
    # Note, ignore events that don't actually report carrier
    if event.carrier is not None and event.ifname == upstream:
        if event.attached and event.up and event.carrier and not upbridge:
            print("Taking bridge up")
            if ip("link set dev %s up" % bridge):
                raise Exception("Could not up bridge")
            upbridge = True
        else:
            print("Taking bridge down")
            if ip("link set dev %s down" % bridge):
                raise Exception("Could not down bridge")
            upbridge = False
