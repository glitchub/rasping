#!/usr/bin/python3 -u
# Note unbuffered output

import os, sys
from getopt import getopt
import subprocess
import rtnl

usage="""
Usage:

    autobridge [options] pattern [... pattern] bridge

Given one or more glob-style network interface name patterns and a bridge name,
create the bridge if necessary and add matching interfaces to it as they
appear.

Options are:

    -i ip.ad.re.ss/nm - specify static IP for the bridge.

    -x pattern - interfaces that match this patterm will always be ignored. Can
    be used multiple times.

    -u inteface - bridge will be down when the upstream interface is missing or
    doesn't have carrier.

"""

# return list of network interfaces, scraped from sysfs
def interfaces(): return os.listdir('/sys/class/net')

# execute the 'ip' command with given command line
def ip(cmd): return subprocess.call(["ip"] + cmd.split())

# parse command line param
bridge = sys.argv[-1]   # bridge name
reject={'lo', bridge}   # list of interfaces to ignore
accept=set()            # list of interfaces to be bridged
upstream=None           # upstream interface, if any
staticip=None           # static IP to apply to bridge, if any

try:
    opts, args = getopt(sys.argv[1:],"u:x:i:")
    if len(args) < 2: raise Exception("Must specify at least one pattern and a bridge name.")
    accept.update(args[:-1])
    bridge=args[-1]
    for opt, arg in opts:
        if opt == "-i":
            if staticip: raise Exception("Can't specify -i more than once.")
            staticip = arg
        elif opt == "-x":
            reject.add(arg)
        elif opt == "-u":
            if upstream: raise Exception("Can't specify -u more than once.")
            upstream = arg     # remember it
            accept.add(arg)    # also autobridge it

except Exception as e:
    print(str(e), usage, file=sys.stderr)
    quit(1)

print("Using bridge %s" % bridge)

if bridge not in interfaces():
    if ip("link add name %s type bridge" % bridge):
        raise Exception("Could not create bridge")

if staticip:
    print("Setting static IP %s" % staticip)
    ip("address flush dev %s" % bridge)
    if ip("address add %s dev %s" % (staticip, bridge)):
        raise Exception("Could not set bridge IP")

if ip("link set dev %s up" % bridge): raise Exception("Could not up bridge")
upbridge=True

print("Auto-bridging interfaces that match %s but not %s" % (str(accept)[1:-1], str(reject)[1:-1]))
if upstream: print("Upstream interface is %s" % upstream)

bridged = set() # bridged interfaces

# configure netlink
nl=rtnl(reject=reject, accept=accept)
nl.dump()   # request initial interface dump
for event in nl.read():
    if not event: continue  # end of dump

    ifname=event["ifname"]
    attached=event["attached"]
    carrier=event["carrier"]
    print("%s: attached=%s carrier=%s" % (ifname, attached, carrier)

    # Bridge up state follows upstream interface, intended to trigger dhcpcd.
    if ifname == upstream and upbridge != carrier:
        if carrier:
            print("Taking bridge up")
            if ip("link set dev %s up" % bridge):
                raise Exception("Could not up bridge")
        else:
            print("Taking bridge down")
            if ip("link set dev %s down" % bridge):
                raise Exception("Could not down bridge")
        upbridge = carrier

    if not attached:
        try: bridged.remove(ifname)
        except KeyError: pass
    elif ifname not in bridged:
        print("Adding %s to bridge" % i)
        bridged.add(ifname)
        if ip("link set dev %s master %s up" % (ifname, bridge)):
            print("Could not add %s, ignoring it" % ifname)
